var _ = require("underscore"),
    crypto = require("crypto"),
    fs = require("fs")
    util = require("util");

/** @constructor */
var Resolver = function (database, baseDir) {
    this.loaded = false;
    this.locked = false;
    this.__dirname = baseDir || __dirname;
    if (database && typeof database == "string")
        this.loadDb(database);
};

/**
 * Loads a shadowDb file
 * @param file {*}
 */
Resolver.prototype.loadDb = function (file) {
    var dbData = {};
    if (file && typeof file == "string") {
        dbData = require(this.__dirname + "/" + file);
        this.loaded = this.__dirname + "/" + file;
    } else {
        dbData = require("passwd.json");
        this.loaded = __dirname + "/" + file;
    }
    /** @private */
    this.algo = dbData["shadow_type"];
    /** @private */
    this.rainbowSafe = dbData["rainbow"] == "yes";
    /** @private */
    this.forward = this.computeForwardTable(dbData["shadows"]);
};

/**
 * Generates hashes for the shadowDb members
 * @private
 * @param input {string}
 * @return {string} base64 encoded representation of the hash of input
 */
Resolver.prototype.hashGenerator = function (input) {
    var hashObj = crypto.createHash(this.algo);
    hashObj.update(input);
    return hashObj.digest('base64');
};

/**
 * Computes the forward table
 * @private
 * @return {object} forward table
 */
Resolver.prototype.computeForwardTable = function (shadows) {
    var result = {},
        parent = this;
    _.each(shadows, function(shadow) {
        var entry = parent.computeEntry(shadow);
        result[entry.key] = entry.value;
    });
    return result;
};

/**
 * Computes key-value pairs for the shadowDb
 * @private
 * @param passPhrase {string}
 * @return {{key: string, value: string}}
 */
Resolver.prototype.computeEntry = function (passPhrase) {
    var hash = this.hashGenerator(passPhrase);
    return {key: hash, value: passPhrase};
};

/**
 * Add new entries to the shadowDb. Use Resolver.save() to write changes to file.
 * @param passPhrase {string}
 * @throws {ReferenceError|Error}
 */
Resolver.prototype.addEntry = function (passPhrase) {
    if (this.locked)
        throw new Error("Database is locked.");
    if (!this.loaded)
        throw new Error("Cannot add entries to an unloaded db!");

    var entry = this.computeEntry(passPhrase);
    if (this.forward[entry.key]) {
        throw new ReferenceError("Entry already exists for '" + entry.key + "'");
    } else {
        this.forward[entry.key] = entry.value;
    }
};

Resolver.prototype.save = function () {
    if (this.locked)
        throw new Error("Database is locked.");
    if (!this.loaded)
        throw new Error("Unloaded database cannot be saved.");

    var dbData = {},
        parent = this;
    this.locked = true;
    dbData["shadow_type"] = this.algo;
    dbData["rainbow"] = (this.rainbowSafe ? "yes" : "no");
    dbData["shadows"] = _.values(this.forward);
    fs.writeFile(this.loaded, JSON.stringify(dbData, null, "    "), function (err) {
        if (err) throw err;
        parent.locked = false;
    });
};

/**
 * Gets the algorithm used for shadowing
 * @return {string} the name of the algorithm
 */
Resolver.prototype.getAlgorithm = function () {
    return this.algo;
};

/**
 * Performs a forward request on the shadowDb
 * @param hash {string}
 * @return {string|boolean}
 * @throws {TypeError|Error}
 */
Resolver.prototype.getPassPhrase = function (hash) {
    if (this.locked)
        throw new Error("Database is locked.");
    if (!this.loaded)
        throw new Error("Resolver request received before a shadowDb was loaded.");

    if (typeof hash == "string") {
        return this.forward[hash] || false;
    } else {
        throw new TypeError("hash must be a string.");
    }
};

/**
 * Performs a reverse request on a PassPhrase
 * @param passPhrase {string}
 * @return {string|boolean}
 * @throws {TypeError|Error}
 */
Resolver.prototype.getShadow = function (passPhrase) {
    if (this.locked)
        throw new Error("Database is locked.");
    if (!this.loaded)
        throw new Error("Resolver request received before a shadowDb was loaded.");

    if (typeof passPhrase == "string") {
        return _.invert(this.forward)[passPhrase] || false;
    } else {
        throw new TypeError("passPhrase must be a string.");
    }
};

module.exports = Resolver;